#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, range(len(correct_date)), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(correct_date, *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
T = 365
#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.linrange(correct_date), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(np.linrange(correct_date), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
T = 365
#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.range(correct_date), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(np.linrange(correct_date), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
T = 365
#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.arange(correct_date), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(np.arange(correct_date), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
T = 365
#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.arange(correct_date), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(np.arange(correct_date), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
T = 365
#temp_mean = [np.mean([max_temp_data[i + T*k] for k in range(round(len(max_temp_data)/T))]) for i in range(T)]
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.arange(correct_date), max_temp_data, p0 = [1/T, 10, 0, 10])
fitted_sin = my_sin(np.arange(correct_date), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
np.arange(7)
sin(np.arange(5))
np.sin(np.arange(5))
def my_sin(x, freq, amplitude, phase, offset):
return np.sin(x * freq + phase) * amplitude + offset
fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), max_temp_data, p0 = [1/365, 10, 0, 10])
fitted_sin = my_sin(np.arange(len(correct_date)), *fit[0])
plt.plot(correct_date, max_temp_data)
plt.plot(correct_date, fitted_sin)
temp_without_seasonality = max_temp_data - fitted_sin
temp_without_seasonality = max_temp_data - fitted_sin
plt.plot(correct_date, temp_without_seasonality)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
plt.plot(correct_date, temp_without_trend)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
temp_without_trend = polyval(linefit, max_temp_data)
plt.plot(correct_date, temp_without_trend)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
temp_without_trend = polyval(linefit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
temp_without_trend = np.polyval(linefit, max_temp_data)
plt.plot(correct_date, temp_without_trend)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data)
temp_without_trend = np.polyval(line_fit, max_temp_data)
plt.plot(correct_date, temp_without_trend)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
temp_without_trend = np.polyval(line_fit, max_temp_data)
plt.plot(correct_date, temp_without_trend)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
print(line_fit)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
print(line_fit)
temp_without_trend = np.polyval(line_fit, max_temp_data)
np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
print(line_fit)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
print(line_fit)
temp_without_trend = np.polyval(line_fit, max_temp_data)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date)))
line_fit
line_fit = np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date)))
np.polyfit(np.arange(len(correct_date), max_temp_data, 1)
np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
temp_without_trend = max_temp_data - np.polyval(line_fit, np.arange(len(correct_date)))
plt.plot(correct_date, temp_without_trend)
def my_sin(x, T, amplitude, phase, offset):
return np.sin(x * 2 * np.pi /T + phase) * amplitude + offset
sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0, 15])
fitted_sin = my_sin(np.arange(len(correct_date)), *sin_fit[0])
plt.plot(correct_date, temp_without_trend, label = "Dane")
plt.plot(correct_date, fitted_sin, label = "Dopasowana funkcja")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
plt.plot(correct_date, max_temp_data, label = "Dane")
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date))), label = "Dopasowana prosta")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
quit
line_fit = py$line_fit
reticulate::repl_python()
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
x = 5
quit
line_fit = py$x
py$x
library(reticulate)
py$x
library(reticulate)
reticulate::repl_python()
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
quit
line_fit <- py$line_fit
sin_fit <- py$sin_fit
println(sin_fit)
sin_fit <- py$sin_fit
print(sin_fit)
sin_fit <- py$sin_fit
print(sin_fit)
reticulate::repl_python()
def my_sin(x, T, amplitude, phase, offset):
return np.sin(x * 2 * np.pi /T + phase) * amplitude + offset
sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0, 15])[0]
quit
sin_fit <- py$sin_fit
print(sin_fit)
reticulate::repl_python()
def my_sin(x, T, amplitude, phase, offset):
return np.sin(x * 2 * np.pi /T + phase) * amplitude + offset
sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0, 15])[0]
quit
sin_fit <- py$sin_fit
print(sin_fit)
reticulate::repl_python()
fitted_sin = my_sin(np.arange(len(correct_date)), *sin_fit)
plt.plot(correct_date, temp_without_trend, label = "Dane")
plt.plot(correct_date, fitted_sin, label = "Dopasowana funkcja okresowa")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
quit
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
knitr::knit_engines$set(python = reticulate::eng_python)
knitr::opts_chunk$set(pythonreticulate = FALSE)
library(reticulate)
reticulate::repl_python()
reticulate::repl_python()
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from scipy import stats, optimize
from statsmodels.tsa.stattools import pacf
from statsmodels.tsa.arima.model import ARIMA
from IPython.display import display
import statsmodels.api as sm
sns.set_style("darkgrid")
sns.set_palette(["steelblue", "red"])
def autocovariance_estimator(data, h):
n = len(data)
h = np.abs(h)
new_first_data = data[h:]
new_second_data = data[:n-h]
mean_data = np.mean(data)
output = (1/n)*sum((new_first_data - mean_data)*(new_second_data - mean_data))
return output
def autocorrelation_estimator(data, h):
data = np.array(data)
autocovariance = autocovariance_estimator(data, h)
variance = autocovariance_estimator(data, 0)
return autocovariance/variance
weather_data = pd.read_csv("london_weather.csv")
max_temp_data = weather_data["max_temp"]
date_data = weather_data["date"]
correct_date = [pd.to_datetime(str(date), format='%Y%m%d') for date in date_data]
weather_data["correct_date"] = correct_date
plt.plot(correct_date, max_temp_data)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
date_data = date_data[:-365]
max_temp_data = max_temp_data[:-365]
correct_date = correct_date[:-365]
H_20 = np.arange(21)
autocorr_20 = [autocorrelation_estimator(max_temp_data, h) for h in H_20]
plt.plot(H_20, autocorr_20)
plt.xlabel("$h$")
plt.ylabel("ACF")
#to pewnie się usunie
H_1000 = np.arange(1001)
autocorr_1000 = [autocorrelation_estimator(max_temp_data, h) for h in H_1000]
plt.plot(H_1000, autocorr_1000)
plt.xlabel("$h$")
plt.ylabel("ACF")
PACF_20 = pacf(max_temp_data, nlags=20)
plt.plot(np.arange(21), PACF_20)
plt.xlabel("$h$")
plt.ylabel("PACF")
PACF_1000 = pacf(max_temp_data, nlags=1000)
plt.plot(np.arange(1001), PACF_1000)
plt.xlabel("$h$")
plt.ylabel("PACF")
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
quit
line_fit <- py$line_fit
reticulate::repl_python()
plt.plot(correct_date, max_temp_data, label = "Dane")
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date))), label = "Dopasowana prosta")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
temp_without_trend = max_temp_data - np.polyval(line_fit, np.arange(len(correct_date)))
plt.plot(correct_date, temp_without_trend)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
def my_sin(x, T, amplitude, phase):
return np.sin(x * 2 * np.pi /T + phase) * amplitude
sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0])[0]
quit
quit
sin_fit <- py$sin_fit
reticulate::repl_python()
fitted_sin = my_sin(np.arange(len(correct_date)), *sin_fit)
plt.plot(correct_date, temp_without_trend, label = "Dane")
plt.plot(correct_date, fitted_sin, label = "Dopasowana funkcja okresowa")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
temp_without_seasonality = temp_without_trend - fitted_sin
plt.plot(correct_date, temp_without_seasonality)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
autocorr_20_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_20]
plt.plot(H_20, autocorr_20_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
autocorr_1000_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_1000]
plt.plot(H_1000, autocorr_1000_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
PACF_20_after = pacf(temp_without_seasonality, nlags=20)
plt.plot(np.arange(21), PACF_20_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
PACF_1000_after = pacf(temp_without_seasonality, nlags=1000)
plt.plot(np.arange(1001), PACF_1000_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
pq_df = pd.read_csv("pq.csv")
#do zmiany na ładniejszą tabelę
display(pq_df)
phi, sigma = sm.regression.yule_walker(max_temp_data, order=6)
p = 6
q = 0
model = ARIMA(order = (p, 0, q))
p = 6
q = 0
model = ARIMA(order = (p, 0, q))
residuals = model.resid
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit()
residuals = model.resid
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit()
residuals = model.resid
print(model.summary())
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit(method = "yule_walker")
residuals = model.resid
print(model.summary())
phi, sigma = sm.regression.yule_walker(max_temp_data, order=6)
phi
pq_df = pd.read_csv("pq.csv")
#do zmiany na ładniejszą tabelę
display(pq_df)
phi, sigma = sm.regression.yule_walker(max_temp_data, order=6)
phi
quit
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
knitr::knit_engines$set(python = reticulate::eng_python)
knitr::opts_chunk$set(pythonreticulate = FALSE)
library(reticulate)
reticulate::repl_python()
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from scipy import stats, optimize
from statsmodels.tsa.stattools import pacf
from statsmodels.tsa.arima.model import ARIMA
from IPython.display import display
import statsmodels.api as sm
sns.set_style("darkgrid")
sns.set_palette(["steelblue", "red"])
def autocovariance_estimator(data, h):
n = len(data)
h = np.abs(h)
new_first_data = data[h:]
new_second_data = data[:n-h]
mean_data = np.mean(data)
output = (1/n)*sum((new_first_data - mean_data)*(new_second_data - mean_data))
return output
def autocorrelation_estimator(data, h):
data = np.array(data)
autocovariance = autocovariance_estimator(data, h)
variance = autocovariance_estimator(data, 0)
return autocovariance/variance
weather_data = pd.read_csv("london_weather.csv")
max_temp_data = weather_data["max_temp"]
date_data = weather_data["date"]
correct_date = [pd.to_datetime(str(date), format='%Y%m%d') for date in date_data]
weather_data["correct_date"] = correct_date
plt.plot(correct_date, max_temp_data)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
date_data = date_data[:-365]
max_temp_data = max_temp_data[:-365]
correct_date = correct_date[:-365]
H_20 = np.arange(21)
autocorr_20 = [autocorrelation_estimator(max_temp_data, h) for h in H_20]
plt.plot(H_20, autocorr_20)
plt.xlabel("$h$")
plt.ylabel("ACF")
#to pewnie się usunie
H_1000 = np.arange(1001)
autocorr_1000 = [autocorrelation_estimator(max_temp_data, h) for h in H_1000]
plt.plot(H_1000, autocorr_1000)
plt.xlabel("$h$")
plt.ylabel("ACF")
PACF_20 = pacf(max_temp_data, nlags=20)
plt.plot(np.arange(21), PACF_20)
plt.xlabel("$h$")
plt.ylabel("PACF")
PACF_1000 = pacf(max_temp_data, nlags=1000)
plt.plot(np.arange(1001), PACF_1000)
plt.xlabel("$h$")
plt.ylabel("PACF")
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
quit
line_fit <- py$line_fit
reticulate::repl_python()
plt.plot(correct_date, max_temp_data, label = "Dane")
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date))), label = "Dopasowana prosta")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
temp_without_trend = max_temp_data - np.polyval(line_fit, np.arange(len(correct_date)))
plt.plot(correct_date, temp_without_trend)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
def my_sin(x, T, amplitude, phase):
return np.sin(x * 2 * np.pi /T + phase) * amplitude
sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0])[0]
quit
sin_fit <- py$sin_fit
reticulate::repl_python()
fitted_sin = my_sin(np.arange(len(correct_date)), *sin_fit)
plt.plot(correct_date, temp_without_trend, label = "Dane")
plt.plot(correct_date, fitted_sin, label = "Dopasowana funkcja okresowa")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
temp_without_seasonality = temp_without_trend - fitted_sin
plt.plot(correct_date, temp_without_seasonality)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
autocorr_20_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_20]
plt.plot(H_20, autocorr_20_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
autocorr_1000_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_1000]
plt.plot(H_1000, autocorr_1000_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
PACF_20_after = pacf(temp_without_seasonality, nlags=20)
plt.plot(np.arange(21), PACF_20_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
PACF_1000_after = pacf(temp_without_seasonality, nlags=1000)
plt.plot(np.arange(1001), PACF_1000_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
pq_df = pd.read_csv("pq.csv")
#do zmiany na ładniejszą tabelę
display(pq_df)
phi, sigma = sm.regression.yule_walker(max_temp_data, order=6)
phi
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit(method = "yule_walker")
residuals = model.resid
print(model.summary())
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit(method = "yule_walker")
residuals = model.resid
print(model.summary())
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit(method = "yule_walker")
residuals = model.resid
p = 6
q = 0
model = ARIMA(temp_without_seasonality, order = (p, 0, q)).fit(method = "yule_walker")
residuals = model.resid
model.plot_diagnostics()
plt.plot()
plt.plot(correct_date, residuals)
plt.plot(np.arange(len(correct_date)), residuals)
plt.xlabel("Numer obserwacji")
plt.ylabel("Wartości resztowe")
quit
pvalue_ttest <- t.test(py$temp_without_seasonality)$p.value
pvalue_ttest <- t.test(py$temp_without_seasonality)$p.value
library(reticulate)
library(aTSA)
install.packages("aTSA")
library(reticulate)
library(aTSA)
pvalue_ljungbox <- Box.test(py$residuals, lag = 1, type = "Ljung-Box", fitdf = 0)$p.value
install.packages(tseries)
install.packages("tseries")
install.packages("tseries")
library(tseries)
install.packages("tseries")
install.packages("tsoutliers")
library(reticulate)
library(aTSA)
library(tsoutliers)
library(reticulate)
library(aTSA)
library(tseries)
library(reticulate)
library(aTSA)
library(stats)
pvalue_archtest <- arch.test(py$model)$p.value
pvalue_shapiro <- ks.test(py$residuals, "pnorm")$p.value
reticulate::repl_python()
sns.histplot(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
plt.ylabel("Gęstość")
sns.hist(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
plt.ylabel("Gęstość")
plt.hist(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
plt.ylabel("Gęstość")
plt.hist(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
plt.plot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
plt.ylabel("Gęstość")
sns.histplot(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
plt.ylabel("Gęstość")
sns.histplot(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
sns.histplot(x = residuals, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
f, ax = plt.subplots(1)
sns.histplot(x = residuals, ax = ax, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-15, 15, 0.001), y = stats.norm.pdf(np.arange(-15, 15, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
ax.set(ylabel = "Gęstość")
plt.savefig('resid_density.pdf')
f, ax = plt.subplots(1)
sns.histplot(x = residuals, ax = ax, kde = True, stat = "density", bins = 20, label = "Gęstość empiryczna")
sns.lineplot(x = np.arange(-10, 10, 0.001), y = stats.norm.pdf(np.arange(-10, 10, 0.001), np.mean(residuals), np.std(residuals)), color = "red", label = "Gęstość rozkładu normalnego")
ax.set(ylabel = "Gęstość")
plt.savefig('resid_density.pdf')
quit
## Założenie dotyczące normalności rozkładu
reticulate::repl_python()
f, ax = plt.subplots(1)
sm.qqplot(residuals, ax = ax)
ax.set(xlabel = "Kwantyle teoretyczne", ylabel = "Kwantyle empiryczne")
plt.savefig("qqplot.pdf")
quit
pvalue_kstest <- ks.test(py$residuals, "pnorm")$p.value
```{r include = FALSE}
pvalue_shapiro <- ks.test(py$residuals, "pnorm")$p.value
```
```{r include = FALSE}
pvalue_shapiro <- ks.test(py$residuals, "pnorm")$p.value
```
install.packages("quadprog")
install.packages("tseries")
install.packages("tseries")
