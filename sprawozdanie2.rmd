---
title: "Sprawozdanie 2"
author: "Kaludia Jaworek, Martyna Bielec"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    extra_dependencies: ["polski", "float"]
  word_document: default
---

```{r setup, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
knitr::knit_engines$set(python = reticulate::eng_python)
knitr::opts_chunk$set(pythonreticulate = FALSE)
```

```{python include = FALSE}
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from scipy import stats, optimize
from statsmodels.tsa.stattools import pacf

sns.set_style("darkgrid")
sns.set_palette(["steelblue", "red"]) 

def autocovariance_estimator(data, h):
    n = len(data)
    h = np.abs(h)
    new_first_data = data[h:]
    new_second_data = data[:n-h]
    mean_data = np.mean(data)
    
    output = (1/n)*sum((new_first_data - mean_data)*(new_second_data - mean_data))
    
    return output

def autocorrelation_estimator(data, h):
  
    data = np.array(data)
    autocovariance = autocovariance_estimator(data, h)
    variance = autocovariance_estimator(data, 0)
    
    return autocovariance/variance
```

# Wstęp

Dane, które poddamy analizie, dotyczą pogody w Londynie w latach 1979-2020. Pomiary były dokonywane codziennie w stacji pogodowej w pobliżu lotniska Heathrow. Zawierają informacje dotyczące m.in. zachmurzenia, nasłonecznienia, ciśnienia oraz temperatury. W sprawozdaniu zajmiemy się analizą maksymalnej temperatury. Sprawdzimy trend deterministyczny i dokonamy dekompozycji, a następnie sprawdzimy jaki szereg czasowy najlepiej modeluje zachowanie danych. Szereg będziemy oznaczać jako $\{X_t\}$.


 
```{python echo = FALSE, fig.cap = "\\label{wykres bez obrobki}Maksymalna temperatura w Londynie.", fig.pos = "H"}

weather_data = pd.read_csv("london_weather.csv")
max_temp_data = weather_data["max_temp"]
date_data = weather_data["date"]
correct_date = [pd.to_datetime(str(date), format='%Y%m%d') for date in date_data]
weather_data["correct_date"] = correct_date
plt.plot(correct_date, max_temp_data)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
```

Z wykresu [\ref{wykres bez obrobki}] odczytujemy, że obserwowane wartości wykazują się sezonowością, zgodnie z oczekiwaniami. 



# Przygotowanie danych do analizy

## Wartości brakujące i obserwacje odstające

W danych znajduje się sześć dni, dla których nie zmierzono maksymalnej temperatury. Są to: 05.02, 10.03, 06.05, 16.07, 10.08 oraz 08.10 z 2020 roku. Z tego powodu weźmiemy pod uwagę jedynie dane sprzed 2020 roku. 

```{python include = FALSE}
date_data = date_data[:-365]
max_temp_data = max_temp_data[:-365]
correct_date = correct_date[:-365]
```

Najwyższa zaobserwowana temperatura wyniosła $37.9 ^\circ$, a najniższa $-6.2^\circ$. Wartości są wiarygodne, skąd wnioskujemy, że dane nie zawierają błędów w pomiarach.

## Dekompozycja szeregu czasowego

### ACF oraz PACF dla surowych danych

ACF jest funkcją korelacji między dwoma obserwacjami z szeregu $\{X_t\}$, oddalonymi o $h$, gdzie $h \in \mathbf{Z}$, czyli $\mathrm{corr}(X_t, X_{t+h})$. Estymuje się ją w natępujący sposób:

$$\hat{\rho}(h) = \frac{\hat{\gamma}(h)}{\hat{\gamma}(0)},$$
gdzie $\hat{\gamma}(h)$ jest empiryczną funkcją autokowariancji, wyrażoną wzorem

$$\hat{\gamma}(h) = \frac{1}{n} \sum_{t=1}^{n - |h|} (x_{t+|h|} - \overline{x})(x_t - \overline{x}),$$

gdzie $x_1, x_2, \dots, x_n$ są realizacjami szeregu czasowego $X_t$, a $\overline{x} = \frac{1}{n}\sum_{i=1}^n x_i$.

Obliczamy ACF dla badanego szeregu czasowego, dla $h=0, 1, 2, \dots 20$.

```{python echo = FALSE, fig.cap = "\\label{fig:ACF bez obrobki 20}ACF dla surowych danych dla $h < 21$.", fig.pos = "H"}

H_20 = np.arange(21)
autocorr_20 = [autocorrelation_estimator(max_temp_data, h) for h in H_20]

plt.plot(H_20, autocorr_20)
plt.xlabel("$h$")
plt.ylabel("ACF")
```



```{python echo = FALSE, fig.cap = "\\label{fig:ACF bez obrobki 1000}ACF dla surowych danych dla $h < 1001$.", fig.pos = "H"}

#to pewnie się usunie

H_1000 = np.arange(1001)
autocorr_1000 = [autocorrelation_estimator(max_temp_data, h) for h in H_1000]

plt.plot(H_1000, autocorr_1000)
plt.xlabel("$h$")
plt.ylabel("ACF")
```

PACF jest funkcją częściowej autokorelacji. Służy do określenia bezpośredniej zależności między $X_t$ a $X_{t+h}$. Definiujemy ją w następujący sposób

$$\alpha(0)=1, \alpha(h) = \phi_{hh}, h \ge 1,$$
gdzie $\phi_{hh}$ jest ostatnią składową $\phi_h = \Gamma_h^{-1}\gamma_h,$ gdzie $\Gamma_h = [\gamma(i-j)]^h_{i,j=i}, \gamma_h = [\gamma(1), \gamma(2), \dots, \gamma(h)]'.$

PACF dla danych obliczymy z użyciem funkcji wbudowanej w języku programowania Python.

```{python echo = FALSE, fig.cap = "\\label{fig:PACF bez obrobki 20}PACF dla surowych danych dla $h < 21$.", fig.pos = "H"}

PACF_20 = pacf(max_temp_data, nlags=20)
plt.plot(np.arange(21), PACF_20)
plt.xlabel("$h$")
plt.ylabel("PACF")
```

```{python echo = FALSE, fig.cap = "\\label{fig:PACF bez obrobki 1000}PACF dla surowych danych dla $h < 1001$.", fig.pos = "H"}

PACF_1000 = pacf(max_temp_data, nlags=1000)
plt.plot(np.arange(1001), PACF_1000)
plt.xlabel("$h$")
plt.ylabel("PACF")
```

### Identyfikacja trendów deterministycznych

```{python echo = FALSE, fig.cap = "\\label{fig:dopasowana prosta}Dopasowanie funkcji liniowej do danych.", fig.pos = "H"}
line_fit = np.polyfit(np.arange(len(correct_date)), max_temp_data, 1)
plt.plot(correct_date, max_temp_data, label = "Dane")
plt.plot(correct_date, np.polyval(line_fit, np.arange(len(correct_date))), label = "Dopasowana prosta")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
```

```{python echo = FALSE, fig.cap = "\\label{fig:bez trendu}Maksymalna temperatura w Londynie po usunięciu trendu liniowego.", fig.pos = "H"}
temp_without_trend = max_temp_data - np.polyval(line_fit, np.arange(len(correct_date)))
plt.plot(correct_date, temp_without_trend)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
```

```{python echo = FALSE, fig.cap = "\\label{fig:dopasowany sinus}Dopasowanie funkcji okresowej do danych.", fig.pos = "H"}
def my_sin(x, T, amplitude, phase, offset):
    return np.sin(x * 2 * np.pi /T + phase) * amplitude + offset

sin_fit = optimize.curve_fit(my_sin, np.arange(len(correct_date)), temp_without_trend, p0 = [365, 20, 0, 15])
fitted_sin = my_sin(np.arange(len(correct_date)), *sin_fit[0])
plt.plot(correct_date, temp_without_trend, label = "Dane")
plt.plot(correct_date, fitted_sin, label = "Dopasowana funkcja okresowa")
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
plt.legend()
```

```{python echo = FALSE, fig.cap = "\\label{fig:bez sezonowości}Maksymalna temperatura w Londynie po usunięciu trendu liniowego i sezonowości.", fig.pos = "H"}
temp_without_seasonality = temp_without_trend - fitted_sin
plt.plot(correct_date, temp_without_seasonality)
plt.xlabel("Czas")
plt.ylabel("Maksymalna temperatura")
```

### ACF oraz PACF dla danych po usunięciu trendów deterministycznych

```{python echo = FALSE, fig.cap = "\\label{fig:ACF po obrobce 20}ACF dla danych po usunięciu trendów deterministycznych dla $h < 21$.", fig.pos = "H"}

autocorr_20_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_20]

plt.plot(H_20, autocorr_20_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
```

```{python echo = FALSE, fig.cap = "\\label{fig:ACF po obrobce 1000}ACF dla danych po usunięciu trendów deterministycznych dla $h < 1001$.", fig.pos = "H"}

autocorr_1000_after = [autocorrelation_estimator(temp_without_seasonality, h) for h in H_1000]

plt.plot(H_1000, autocorr_1000_after)
plt.xlabel("$h$")
plt.ylabel("ACF")
```

```{python echo = FALSE, fig.cap = "\\label{fig:PACF po obrobce 20}PACF dla danych po usunięciu trendów deterministycznych dla $h < 21$.", fig.pos = "H"}

PACF_20_after = pacf(temp_without_seasonality, nlags=20)
plt.plot(np.arange(21), PACF_20_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
```

```{python echo = FALSE, fig.cap = "\\label{fig:PACF po obrobce 1000}PACF dla danych po usunięciu trendów deterministycznych dla $h < 1001$.", fig.pos = "H"}

PACF_1000_after = pacf(temp_without_seasonality, nlags=1000)
plt.plot(np.arange(1001), PACF_1000_after)
plt.xlabel("$h$")
plt.ylabel("PACF")
```
